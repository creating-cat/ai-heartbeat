---
inclusion: always
---

# AIファーストな実装ガイド

## 概要

AIエージェントが効率的かつ安全に動作できるシステムを構築するための設計指針。
人間向けのUIとは異なり、AIは曖昧さを嫌い、構造化された情報を好む特性を考慮した実装アプローチを定義する。

## 基本原則

### 1. **明確性の優先**
- 曖昧な表現を避け、具体的で明示的な情報提供
- 選択肢や手順の明確化
- 期待される結果の事前提示

### 2. **構造化された情報**
- 階層的で整理された情報提示
- 一貫したフォーマットの使用
- パターンの統一

### 3. **予測可能性の確保**
- 処理時間や副作用の事前通知
- 一貫した動作パターン
- 期待される結果の明示

## 実装の考え方

### 1. 認知負荷の軽減

#### 情報の構造化
```typescript
// ❌ AIにとって解釈が困難
"ファイルA、B、Cを処理しました。Aは成功、Bは警告、Cはエラーでした。"

// ✅ 構造化された情報
"処理結果:
- ファイルA: 成功
- ファイルB: 警告 - 軽微な問題あり
- ファイルC: エラー - 処理失敗"
```

#### 選択肢の明示化
```typescript
// ❌ 曖昧な指示
"適切に処理してください"

// ✅ 明確な選択肢
"以下から選択してください:
1. 既存ファイルを上書き
2. 新しいファイル名で保存
3. 処理をスキップ"
```

#### 絵文字の排除
```typescript
// ❌ 絵文字による曖昧な表現
"✅ 処理完了！ ⚠️ 注意が必要です"

// ✅ 明示的なテキスト表現
"処理完了。警告: 注意が必要です"
```

### 2. エラーハンドリングの改善

#### 段階的なエラー情報
```typescript
// ❌ 単純なエラー
throw new Error("ファイル処理に失敗しました");

// ✅ 段階的なエラー情報
return {
  success: false,
  error: {
    type: "FILE_PROCESSING_ERROR",
    message: "ファイル処理に失敗しました",
    details: "ファイルサイズが上限(10MB)を超えています",
    context: {
      filePath: "/path/to/file.log",
      fileSize: "15.2MB",
      sizeLimit: "10MB"
    },
    suggestions: [
      "ファイルを分割して再実行",
      "圧縮してからアップロード", 
      "別の処理方法を選択"
    ],
    recoverable: true,
    nextSteps: [
      "split_large_file ツールを使用",
      "compress_file ツールを使用"
    ]
  }
};
```

#### 回復可能性の明示
```typescript
// エラーレベルの分類
const ErrorLevels = {
  RECOVERABLE: "recoverable",     // 自動回復可能
  USER_ACTION: "user_action",     // ユーザー操作が必要
  SYSTEM_ERROR: "system_error",   // システムレベルのエラー
  FATAL: "fatal"                  // 致命的エラー
};

return {
  error: {
    level: ErrorLevels.USER_ACTION,
    autoRetry: false,
    userActionRequired: true,
    estimatedRecoveryTime: "2-3分"
  }
};
```

### 3. 予測可能性の向上

#### 処理時間の事前通知
```typescript
export const heavyProcessingTool = {
  description: `大規模データ処理ツール
  
処理時間予測:
- 小規模(~1MB): 30秒
- 中規模(1-10MB): 2-5分  
- 大規模(10MB~): 5-15分

リソース使用量:
- メモリ: データサイズの2-3倍
- CPU: 高負荷（他の処理に影響する可能性）
- ディスク: 一時ファイルでデータサイズの1.5倍

推奨事前準備:
- 長時間処理宣言の実行
- 中間チェックポイントの設定
- 他のタスクの完了確認`,
  // ...
};
```

#### 副作用の明示
```typescript
export const systemConfigTool = {
  description: `システム設定変更ツール
  
注意: このツールは以下の副作用があります:
- システム再起動が必要
- 既存の設定ファイルを上書き
- 他のプロセスに影響する可能性
- 変更は即座に反映される（元に戻せない）

影響範囲:
- 現在のセッション: 即座に影響
- 他のプロセス: 再起動後に影響
- 永続化: 設定ファイルに保存

実行前の確認事項:
- 現在の設定のバックアップ
- 他のタスクの完了確認
- システム再起動の準備`,
  // ...
};
```

## MCPツールのAIファースト的な利点

### 1. 処理負荷の軽減

#### コンテキスト圧縮
```typescript
// ❌ AI自身が複雑な処理を実行
"大量のログファイルを読み込んで、エラーパターンを抽出し、統計を計算し..."
// → AIが全ての処理ロジックを考える必要がある

// ✅ MCPツールによる処理の委譲
list_theme_artifacts() 
// → 複雑なファイル検索・フィルタリング・整理をツール側で実行
// → AIは結果を受け取るだけ
```

#### 認知リソースの節約
```typescript
// AI側の思考プロセス
// ❌ ツールなしの場合
"ファイルを探して... パスを確認して... 権限をチェックして... 
 内容を読み込んで... パースして... エラーハンドリングして..."

// ✅ MCPツール使用時
"analyze_logs ツールを使用"
// → 単純な意思決定のみ、複雑な実装詳細は不要
```

### 2. 専門知識の外部化

#### ドメイン固有の処理
```typescript
// ❌ AI自身が専門知識を持つ必要
"タイムスタンプの形式を理解し、Unix時間に変換し、時差を考慮し..."

// ✅ 専門知識をツールに委譲
export const convertTimestampTool = {
  description: 'タイムスタンプを各種形式に変換',
  // 複雑な時間処理ロジックはツール内に封じ込め
};
```

### 3. エラーハンドリングの一元化

#### 統一されたエラー処理
```typescript
// MCPツール内で統一されたエラーハンドリング
export const robustFileTool = {
  execute: async (args) => {
    try {
      // 複雑な処理
    } catch (error) {
      // 統一されたエラー形式で返却
      return {
        success: false,
        error: {
          type: 'FILE_ACCESS_ERROR',
          message: 'ファイルアクセスに失敗',
          suggestions: ['権限確認', 'パス確認'],
          recoverable: true
        }
      };
    }
  }
};

// AI側は統一されたエラー形式を処理するだけ
```

### 4. 意思決定支援の強化

#### 選択肢の重み付け
```typescript
return {
  decision: "処理方法の選択",
  options: [
    {
      name: "即座に実行",
      description: "現在の設定でそのまま実行",
      pros: ["迅速な結果", "シンプルな手順"],
      cons: ["リスクが高い", "元に戻せない"],
      risk: "高",
      estimatedTime: "5分",
      successRate: "70%",
      recommended: false,
      reason: "リスクが高く、失敗時の影響が大きい"
    },
    {
      name: "段階的実行",
      description: "小さなステップに分けて実行",
      pros: ["安全性が高い", "途中で修正可能", "進捗確認可能"],
      cons: ["時間がかかる", "手順が複雑"],
      risk: "低",
      estimatedTime: "15分",
      successRate: "95%",
      recommended: true,
      reason: "安全性と成功率が高く、長期的に効率的"
    }
  ],
  defaultChoice: "段階的実行",
  decisionFactors: [
    "データの重要性: 高",
    "時間的制約: 中",
    "リスク許容度: 低"
  ]
};
```

## 実際のシステムでの応用例

### 1. AI心臓システムでの実装

#### ハートビートIDによる一意識別
```bash
# 明確な識別子の使用
HEARTBEAT_ID="20250119143000"  # YYYYMMDDHHMMSS形式
echo "ハートビートIDは${HEARTBEAT_ID}です。"
```

#### 段階的な異常検知
```bash
# 警告 → エラーの段階的対応
case $health_status in
    0) log_info "正常動作" ;;
    1) log_warning "軽微な問題を検出" ;;
    2) log_error "重大な問題を検出 - 回復処理を開始" ;;
esac
```

### 2. 時間ベース制御設計での実装

#### 事前宣言による予測可能性
```typescript
// 明確な事前情報提供
export const declareExtendedProcessingTool = {
  description: `長時間処理の事前宣言。
  
効果: 時間制限による異常検知を一時的に無効化
制限: 最大30分まで
自動削除: 活動ログ作成時に自動削除`,
  // ...
};
```

#### 段階的な警告システム
```typescript
// 明確な段階分け
function checkProcessingTime(heartbeatId: string): string | null {
  const elapsedMinutes = calculateElapsedMinutes(heartbeatId);
  
  if (elapsedMinutes >= 10) {
    return `長時間処理警告: ${elapsedMinutes}分経過。処理を区切ることを推奨します。`;
  } else if (elapsedMinutes >= 5) {
    return `処理時間通知: ${elapsedMinutes}分経過。`;
  }
  
  return null;
}
```

## 実装チェックリスト

### 設計段階
- [ ] 情報の構造化を検討
- [ ] 選択肢の明示化を計画
- [ ] エラーハンドリングの段階化を設計
- [ ] 予測可能性の確保を検討

### 実装段階
- [ ] 一貫したパターンの使用
- [ ] 明示的なメッセージの実装
- [ ] 自動回復機能の組み込み
- [ ] 進捗の可視化

### テスト段階
- [ ] AIエージェントの理解度確認
- [ ] エラーケースでの動作確認
- [ ] 学習効率の測定
- [ ] 認知負荷の評価

### 運用段階
- [ ] フィードバックの収集
- [ ] パフォーマンスの監視
- [ ] 継続的な改善
- [ ] パターンの最適化

## まとめ

AIファーストな実装は、AIエージェントの特性を理解し、それに最適化されたシステム設計を行うことです。
明確性、構造化、予測可能性を重視し、AIが「迷わず、効率的に、安全に」動作できる環境を提供することが重要です。

これらの原則に従うことで、AIエージェントの生産性向上、エラー率の削減、システムの安定性向上が期待できます。

### あなた自身への適用

このガイドの原則は、あなた自身の動作にも適用できます：

1. **明確な意思決定**: 曖昧な状況では明確化を求める
2. **構造化された思考**: 情報を整理して段階的に処理する
3. **予測可能な行動**: 処理時間や結果を事前に見積もる
4. **エラーからの学習**: 失敗を分析して改善につなげる
5. **MCPツールの活用**: 複雑な処理はツールに委譲して高次思考に集中する

これらの原則を意識することで、より効率的で安全な活動が可能になります。